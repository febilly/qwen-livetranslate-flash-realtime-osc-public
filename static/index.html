<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®æ—¶è¯­éŸ³ç¿»è¯‘ - é€šä¹‰åƒé—®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #333;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2rem;
        }

        .header p {
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        .main-container {
            flex: 1;
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .video-section {
            flex: 1;
            min-width: 300px;
        }

        .video-container {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
        }

        .video-header {
            background: #3498db;
            color: white;
            padding: 15px 20px;
            font-weight: 600;
            font-size: 1.1rem;
        }

        #videoElement {
            width: 100%;
            height: 300px;
            object-fit: cover;
            background: #000;
        }

        .controls-section {
            flex: 1;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .video-section .control-panel {
            margin-bottom: 20px;
        }

        .video-section .control-panel:last-child {
            margin-bottom: 0;
        }

        .panel-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
        }

        .form-group select, 
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .form-group select:focus,
        .form-group input:focus {
            outline: none;
            border-color: #3498db;
        }

        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 120px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #27ae60;
        }

        .status-indicator.disconnected {
            background: #e74c3c;
        }

        .status-indicator.connecting {
            background: #f39c12;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .translation-display {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            min-height: 200px;
        }

        .translation-content {
            max-height: 300px;
            overflow-y: auto;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            line-height: 1.6;
            font-size: 1.1rem;
        }

        .audio-visualizer {
            height: 60px;
            background: #2c3e50;
            border-radius: 8px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }

        .audio-bars {
            display: flex;
            align-items: end;
            height: 100%;
            padding: 10px;
            gap: 3px;
        }

        .audio-bar {
            background: #3498db;
            width: 4px;
            min-height: 5px;
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .connection-status {
            text-align: center;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 10px;
            font-weight: 500;
        }

        .connection-status.connected {
            background: #d5f4e6;
            color: #27ae60;
            border: 1px solid #27ae60;
        }

        .connection-status.disconnected {
            background: #fdeaea;
            color: #e74c3c;
            border: 1px solid #e74c3c;
        }

        .connection-status.connecting {
            background: #fef9e7;
            color: #f39c12;
            border: 1px solid #f39c12;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                padding: 10px;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .checkbox-group input[type="checkbox"] {
            margin-right: 10px;
            width: auto;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ¤ å®æ—¶è¯­éŸ³ç¿»è¯‘</h1>
        <p>åŸºäºé€šä¹‰åƒé—® qwen3-livetranslate-flash-realtime çš„è§†é¢‘è¯­éŸ³ç¿»è¯‘æœåŠ¡</p>
    </div>

    <div class="main-container">
        <!-- è§†é¢‘åŒºåŸŸ -->
        <div class="video-section">
            <div class="video-container">
                <div class="video-header">
                    ğŸ“¹ æ‘„åƒå¤´è§†é¢‘æµ (æµç•…æ˜¾ç¤ºï¼Œå‘é€2å¸§/ç§’)
                </div>
                <video id="videoElement" autoplay muted playsinline></video>
            </div>
            
            <!-- éº¦å…‹é£é€‰æ‹©é¢æ¿ -->
            <div class="control-panel">
                <div class="panel-title">ğŸ¤ éº¦å…‹é£é€‰æ‹©</div>
                <div class="form-group">
                    <label for="microphoneSelect">é€‰æ‹©éº¦å…‹é£è®¾å¤‡</label>
                    <select id="microphoneSelect">
                        <option value="">åŠ è½½ä¸­...</option>
                    </select>
                </div>
            </div>
            
            <!-- éŸ³é¢‘å¯è§†åŒ– -->
            <div class="control-panel">
                <div class="panel-title">ğŸµ éŸ³é¢‘å¯è§†åŒ–</div>
                <div class="audio-visualizer">
                    <div class="audio-bars" id="audioBars">
                        <!-- éŸ³é¢‘æ¡å°†åŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
            </div>
        </div>

        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="controls-section">
            <div class="connection-status disconnected" id="connectionStatus">
                <span class="status-indicator disconnected"></span>
                æœªè¿æ¥
            </div>

            <div class="control-panel">
                <div class="panel-title">âš™ï¸ é…ç½®è®¾ç½®</div>
                
                <div class="form-group">
                    <label for="targetLanguage">ç›®æ ‡è¯­è¨€</label>
                    <select id="targetLanguage">
                        <option value="en">è‹±è¯­ (éŸ³é¢‘+æ–‡æœ¬)</option>
                        <option value="zh">ä¸­æ–‡ (éŸ³é¢‘+æ–‡æœ¬)</option>
                        <option value="ru">ä¿„è¯­ (éŸ³é¢‘+æ–‡æœ¬)</option>
                        <option value="fr">æ³•è¯­ (éŸ³é¢‘+æ–‡æœ¬)</option>
                        <option value="de">å¾·è¯­ (éŸ³é¢‘+æ–‡æœ¬)</option>
                        <option value="pt">è‘¡è„ç‰™è¯­ (éŸ³é¢‘+æ–‡æœ¬)</option>
                        <option value="es">è¥¿ç­ç‰™è¯­ (éŸ³é¢‘+æ–‡æœ¬)</option>
                        <option value="it">æ„å¤§åˆ©è¯­ (éŸ³é¢‘+æ–‡æœ¬)</option>
                        <option value="ko">éŸ©è¯­ (éŸ³é¢‘+æ–‡æœ¬)</option>
                        <option value="ja" selected>æ—¥è¯­ (éŸ³é¢‘+æ–‡æœ¬)</option>
                        <option value="yue">ç²¤è¯­ (éŸ³é¢‘+æ–‡æœ¬)</option>
                        <option value="id">å°å°¼è¯­ (ä»…æ–‡æœ¬)</option>
                        <option value="vi">è¶Šå—è¯­ (ä»…æ–‡æœ¬)</option>
                        <option value="th">æ³°è¯­ (ä»…æ–‡æœ¬)</option>
                        <option value="ar">é˜¿æ‹‰ä¼¯è¯­ (ä»…æ–‡æœ¬)</option>
                        <option value="hi">å°åœ°è¯­ (ä»…æ–‡æœ¬)</option>
                        <option value="el">å¸Œè…Šè¯­ (ä»…æ–‡æœ¬)</option>
                        <option value="tr">åœŸè€³å…¶è¯­ (ä»…æ–‡æœ¬)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="voiceSelect">è¯­éŸ³éŸ³è‰²</label>
                    <select id="voiceSelect">
                        <option value="Cherry" selected>1. Cherry (å¥³å£°) [é»˜è®¤]</option>
                        <option value="Nofish">2. Nofish (ç”·å£°)</option>
                        <option value="Sunny">3. æ™´å„¿ Sunny (å››å·å¥³å£°)</option>
                        <option value="Jada">4. é˜¿ç Jada (ä¸Šæµ·å¥³å£°)</option>
                        <option value="Dylan">5. æ™“ä¸œ Dylan (åŒ—äº¬ç”·å£°)</option>
                        <option value="Peter">6. æå½¼å¾— Peter (å¤©æ´¥ç”·å£°)</option>
                        <option value="Eric">7. ç¨‹å· Eric (å››å·ç”·å£°)</option>
                        <option value="Kiki">8. é˜¿æ¸… Kiki (ç²¤è¯­å¥³å£°)</option>
                    </select>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="audioEnabled">
                    <label for="audioEnabled">å¯ç”¨éŸ³é¢‘è¾“å‡º</label>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="cameraEnabled">
                    <label for="cameraEnabled">å¯ç”¨æ‘„åƒå¤´</label>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="oscMuteControl" checked>
                    <label for="oscMuteControl">æ¸¸æˆé™éŸ³æ—¶åœæ­¢å¤„ç†è¯­éŸ³</label>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="sendToOsc" checked>
                    <label for="sendToOsc">å‘é€ç¿»è¯‘ç»“æœåˆ°OSC</label>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="disableEchoCancellation">
                    <label for="disableEchoCancellation">ç¦ç”¨æµè§ˆå™¨å›å£°æ¶ˆé™¤</label>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" id="startBtn">å¼€å§‹ç¿»è¯‘</button>
                    <button class="btn btn-danger" id="stopBtn" disabled>åœæ­¢ç¿»è¯‘</button>
                </div>
            </div>

            <div class="translation-display">
                <div class="panel-title">ğŸ“ ç¿»è¯‘ç»“æœ</div>
                <div class="translation-content" id="translationContent">
                    ç­‰å¾…å¼€å§‹ç¿»è¯‘...
                </div>
            </div>
        </div>
    </div>

    <script>
        class LiveTranslateApp {
            constructor() {
                this.ws = null;
                this.mediaRecorder = null;
                this.audioStream = null;
                this.videoStream = null;
                this.isRecording = false;
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.animationId = null;
                this.videoIntervalId = null;
                this.playbackAudioContext = null;
                this.playbackQueue = [];
                this.isAudioPlaying = false;
                
                this.initElements();
                this.bindEvents();
                this.enumerateAudioDevices();
                this.requestUserMedia();
            }

            initElements() {
                this.videoElement = document.getElementById('videoElement');
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.translationContent = document.getElementById('translationContent');
                this.targetLanguage = document.getElementById('targetLanguage');
                this.voiceSelect = document.getElementById('voiceSelect');
                this.audioEnabled = document.getElementById('audioEnabled');
                this.cameraEnabled = document.getElementById('cameraEnabled');
                this.oscMuteControl = document.getElementById('oscMuteControl');
                this.sendToOsc = document.getElementById('sendToOsc');
                this.disableEchoCancellation = document.getElementById('disableEchoCancellation');
                this.audioBars = document.getElementById('audioBars');
                this.microphoneSelect = document.getElementById('microphoneSelect');
                
                // åˆ›å»ºéŸ³é¢‘å¯è§†åŒ–æ¡
                for (let i = 0; i < 32; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'audio-bar';
                    this.audioBars.appendChild(bar);
                }
            }

            bindEvents() {
                this.startBtn.onclick = () => this.startTranslation();
                this.stopBtn.onclick = () => this.stopTranslation();
                this.cameraEnabled.onchange = () => this.toggleCamera();
                this.targetLanguage.onchange = () => this.restartSession();
                this.voiceSelect.onchange = () => this.restartSession();
                this.audioEnabled.onchange = () => this.pushSessionUpdate();
                this.microphoneSelect.onchange = () => this.changeMicrophone();
            }

            async requestUserMedia() {
                try {
                    const timestamp = new Date().toLocaleTimeString();
                    console.log(`[${timestamp}] è¯·æ±‚ç”¨æˆ·åª’ä½“æƒé™...`);
                    
                    // ä»…è¯·æ±‚éº¦å…‹é£ï¼Œæ‘„åƒå¤´æŒ‰éœ€å•ç‹¬è·å–
                    const echoCancellationEnabled = !this.disableEchoCancellation.checked;
                    console.log(`[${timestamp}] å›å£°æ¶ˆé™¤è®¾ç½®: ${echoCancellationEnabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
                    
                    const constraints = {
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: echoCancellationEnabled,
                            noiseSuppression: true
                        }
                    };
                    
                    // å¦‚æœå·²é€‰æ‹©ç‰¹å®šéº¦å…‹é£ï¼Œä½¿ç”¨è¯¥è®¾å¤‡
                    if (this.selectedMicrophoneId) {
                        constraints.audio.deviceId = { exact: this.selectedMicrophoneId };
                    }
                    
                    this.audioStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    // æ£€æŸ¥éŸ³é¢‘è½¨é“
                    const audioTracks = this.audioStream.getAudioTracks();
                    
                    console.log(`[${timestamp}] è·å–åˆ° ${audioTracks.length} ä¸ªéŸ³é¢‘è½¨é“`);
                    
                    if (audioTracks.length > 0) {
                        const track = audioTracks[0];
                        const settings = track.getSettings();
                        console.log(`[${timestamp}] éŸ³é¢‘è½¨é“ä¿¡æ¯:`, {
                            label: track.label,
                            enabled: track.enabled,
                            readyState: track.readyState,
                            settings: settings
                        });
                        
                        // ä¿å­˜å½“å‰ä½¿ç”¨çš„è®¾å¤‡IDï¼ˆç³»ç»Ÿé»˜è®¤éº¦å…‹é£ï¼‰
                        if (settings.deviceId) {
                            this.selectedMicrophoneId = settings.deviceId;
                            console.log(`[${timestamp}] ç³»ç»Ÿé»˜è®¤éº¦å…‹é£è®¾å¤‡ID: ${settings.deviceId}`);
                        }
                    } else {
                        console.error(`[${timestamp}] æ²¡æœ‰è·å–åˆ°éŸ³é¢‘è½¨é“ï¼`);
                    }
                    
                this.setupAudioVisualization();
                console.log(`[${timestamp}] ç”¨æˆ·åª’ä½“å·²è·å–`);
                
                // è·å–æƒé™åé‡æ–°æšä¸¾è®¾å¤‡ä»¥æ˜¾ç¤ºè®¾å¤‡æ ‡ç­¾
                await this.enumerateAudioDevices();

            } catch (error) {
                console.error('è·å–ç”¨æˆ·åª’ä½“å¤±è´¥:', error);
                alert('éœ€è¦æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™æ‰èƒ½ä½¿ç”¨ç¿»è¯‘åŠŸèƒ½');
            }
            }

            async enumerateAudioDevices() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const audioInputDevices = devices.filter(device => device.kind === 'audioinput');
                    
                    this.microphoneSelect.innerHTML = '';
                    
                    if (audioInputDevices.length === 0) {
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = 'æ²¡æœ‰æ‰¾åˆ°éº¦å…‹é£è®¾å¤‡';
                        this.microphoneSelect.appendChild(option);
                        return;
                    }
                    
                    audioInputDevices.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label || `éº¦å…‹é£ ${index + 1}`;
                        this.microphoneSelect.appendChild(option);
                    });
                    
                    // å¦‚æœæœ‰å·²é€‰æ‹©çš„è®¾å¤‡ï¼Œä¿æŒé€‰æ‹©
                    if (this.selectedMicrophoneId) {
                        this.microphoneSelect.value = this.selectedMicrophoneId;
                    }
                    
                    console.log(`å‘ç° ${audioInputDevices.length} ä¸ªéŸ³é¢‘è¾“å…¥è®¾å¤‡`);
                } catch (error) {
                    console.error('æšä¸¾éŸ³é¢‘è®¾å¤‡å¤±è´¥:', error);
                    this.microphoneSelect.innerHTML = '<option value="">æ— æ³•è·å–è®¾å¤‡åˆ—è¡¨</option>';
                }
            }

            async changeMicrophone() {
                const selectedDeviceId = this.microphoneSelect.value;
                if (!selectedDeviceId) return;
                
                this.selectedMicrophoneId = selectedDeviceId;
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] åˆ‡æ¢éº¦å…‹é£: ${selectedDeviceId}`);
                
                // å¦‚æœæ­£åœ¨å½•éŸ³ï¼Œéœ€è¦é‡æ–°è·å–åª’ä½“æµ
                const wasRecording = this.isRecording;
                
                // åœæ­¢å½“å‰çš„éŸ³é¢‘æµå’Œå¯è§†åŒ–
                if (this.audioStream) {
                    this.audioStream.getTracks().forEach(track => track.stop());
                    this.audioStream = null;
                }
                
                // åœæ­¢éŸ³é¢‘ä¸Šä¸‹æ–‡
                if (this.audioContext) {
                    if (this.analyser) {
                        try { this.analyser.disconnect(); } catch {}
                    }
                    try { await this.audioContext.close(); } catch {}
                    this.audioContext = null;
                    this.analyser = null;
                }
                
                // åœæ­¢å½•éŸ³ç›¸å…³ç»„ä»¶
                this.stopPcmCapture();
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();
                    this.mediaRecorder = null;
                }
                
                // é‡æ–°è·å–åª’ä½“æµ
                try {
                    const echoCancellationEnabled = !this.disableEchoCancellation.checked;
                    this.audioStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined,
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: echoCancellationEnabled,
                            noiseSuppression: true
                        }
                    });
                    
                    console.log(`[${timestamp}] å·²åˆ‡æ¢åˆ°æ–°éº¦å…‹é£è®¾å¤‡`);
                    
                    // é‡æ–°è®¾ç½®éŸ³é¢‘å¯è§†åŒ–
                    this.setupAudioVisualization();
                    
                    // å¦‚æœä¹‹å‰åœ¨å½•éŸ³ï¼Œé‡æ–°å¼€å§‹å½•éŸ³
                    if (wasRecording) {
                        this.startRecording();
                    }
                } catch (error) {
                    console.error('åˆ‡æ¢éº¦å…‹é£å¤±è´¥:', error);
                    alert('åˆ‡æ¢éº¦å…‹é£å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            }

            setupAudioVisualization() {
            if (this.audioContext) return;
                
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = this.audioContext.createMediaStreamSource(this.audioStream);
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 64;
                source.connect(this.analyser);
                
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.visualizeAudio();
            }

            visualizeAudio() {
                const bars = this.audioBars.children;
                
                const animate = () => {
                    if (this.analyser) {
                        this.analyser.getByteFrequencyData(this.dataArray);
                        
                        for (let i = 0; i < bars.length; i++) {
                            const barHeight = (this.dataArray[i] / 255) * 40 + 5;
                            bars[i].style.height = `${barHeight}px`;
                        }
                    }
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                
                animate();
            }

            updateConnectionStatus(status, message) {
                const indicator = this.connectionStatus.querySelector('.status-indicator');
                
                this.connectionStatus.className = `connection-status ${status}`;
                indicator.className = `status-indicator ${status}`;
                this.connectionStatus.innerHTML = `<span class="status-indicator ${status}"></span>${message}`;
            }

            async startTranslation() {
                if (!this.audioStream) {
                    alert('è¯·å…ˆå…è®¸æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™');
                    return;
                }

                try {
                    // æ„å»ºWebSocket URL with parameters
                    const wsUrl = new URL('/ws', window.location);
                    wsUrl.protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    wsUrl.searchParams.set('target_language', this.targetLanguage.value);
                    wsUrl.searchParams.set('voice', this.voiceSelect.value);
                    wsUrl.searchParams.set('audio_enabled', this.audioEnabled.checked);
                    wsUrl.searchParams.set('osc_mute_control', this.oscMuteControl.checked);
                    wsUrl.searchParams.set('send_to_osc', this.sendToOsc.checked);

                    this.ws = new WebSocket(wsUrl.toString());
                    
                    this.ws.onopen = () => {
                        console.log('WebSocketè¿æ¥å·²å»ºç«‹');
                        this.updateConnectionStatus('connected', 'å·²è¿æ¥');
                        this.startRecording();
                        if (this.cameraEnabled.checked) this.startVideoCapture();
                        this.startBtn.disabled = true;
                        this.stopBtn.disabled = false;
                        // ä¸åœ¨ onopen ç«‹å³ pushï¼Œä¼šä¸åˆå§‹ session.update å†²çªå¯¼è‡´ TTS é‡ç½®
                    };

                    this.ws.onmessage = (event) => {
                        const timestamp = new Date().toLocaleTimeString();
                        
                        if (typeof event.data === 'string') {
                            console.log(`[${timestamp}] å®¢æˆ·ç«¯æ”¶åˆ°æ–‡æœ¬äº‹ä»¶:`, event.data);
                            
                            if (event.data === 'interrupt') {
                                console.log(`[${timestamp}] æ”¶åˆ°ä¸­æ–­ä¿¡å·`);
                                return;
                            }
                            
                            try {
                                const message = JSON.parse(event.data);
                                console.log(`[${timestamp}] è§£æJSONæ¶ˆæ¯:`, message);
                                if (message.type === 'translation_text') {
                                    console.log(`[${timestamp}] æ”¶åˆ°ç¿»è¯‘æ–‡æœ¬: ${message.data}`);
                                    this.appendTranslation(message.data);
                                }
                            } catch (e) {
                                console.log(`[${timestamp}] æ”¶åˆ°æ™®é€šæ–‡æœ¬æ¶ˆæ¯:`, event.data);
                            }
                    } else if (event.data instanceof Blob) {
                        console.log(`[${timestamp}] æ”¶åˆ°éŸ³é¢‘Blobæ•°æ®: ${event.data.size} bytes, ç±»å‹: ${event.data.type}`);
                        this.enqueueAudioBlob(event.data);
                    } else if (event.data instanceof ArrayBuffer) {
                        console.log(`[${timestamp}] æ”¶åˆ°ArrayBufferæ•°æ®: ${event.data.byteLength} bytes`);
                        const audioBlob = new Blob([event.data], { type: 'audio/pcm' });
                        this.enqueueAudioBlob(audioBlob);
                        } else {
                            console.log(`[${timestamp}] æ”¶åˆ°æœªçŸ¥ç±»å‹æ•°æ®:`, typeof event.data, event.data);
                        }
                    };

                    this.ws.onclose = (event) => {
                        console.log('WebSocketè¿æ¥å·²å…³é—­', event);
                        this.updateConnectionStatus('disconnected', 'è¿æ¥å·²å…³é—­');
                        this.stopRecording();
                        this.stopVideoCapture();
                        this.startBtn.disabled = false;
                        this.stopBtn.disabled = true;
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocketé”™è¯¯:', error);
                        this.updateConnectionStatus('disconnected', 'è¿æ¥é”™è¯¯');
                    };

                    this.updateConnectionStatus('connecting', 'è¿æ¥ä¸­...');
                    
                } catch (error) {
                    console.error('å¯åŠ¨ç¿»è¯‘å¤±è´¥:', error);
                    this.updateConnectionStatus('disconnected', 'è¿æ¥å¤±è´¥');
                }
            }

            restartSession() {
                // ç›®çš„ï¼šåœ¨è¯­è¨€/éŸ³è‰²æ›´æ”¹åï¼Œå¦‚æœæ­£åœ¨ç¿»è¯‘åˆ™é‡å¯ä¼šè¯å¹¶åº”ç”¨æ–°å‚æ•°ï¼›å¦åˆ™ä»…æ›´æ–°é…ç½®
                const t = new Date().toLocaleTimeString();
                
                // æ£€æŸ¥æ˜¯å¦æ­£åœ¨ç¿»è¯‘ä¸­
                const wasRecording = this.isRecording;
                
                if (!wasRecording) {
                    console.log(`[${t}] æ£€æµ‹åˆ°é…ç½®å˜æ›´ï¼Œä½†æœªåœ¨ç¿»è¯‘ä¸­ï¼Œä»…æ›´æ–°é…ç½®`);
                    return;
                }
                
                console.log(`[${t}] æ£€æµ‹åˆ°é…ç½®å˜æ›´ï¼Œé‡å¯ä¼šè¯...`);
                try {
                    // å…³é—­ç°æœ‰è¿æ¥ï¼ˆè‹¥å­˜åœ¨ï¼‰
                    if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
                        try { this.ws.close(); } catch {}
                        this.ws = null;
                    }
                    // åœæ­¢å½“å‰é‡‡é›†ï¼Œä½†ä¿ç•™å·²è·å–çš„åª’ä½“æµä»¥ä¾¿å¿«é€Ÿé‡è¿
                    this.stopRecording();
                    this.stopVideoCapture();
                    // ç«‹å³æŒ‰æ–°å‚æ•°é‡è¿
                    this.startTranslation();
                } catch (e) {
                    console.error(`[${t}] é‡å¯ä¼šè¯å¤±è´¥:`, e);
                }
            }

            pushSessionUpdate() {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
                const payload = {
                    type: 'session.update',
                    target_language: this.targetLanguage.value,
                    voice: this.voiceSelect.value,
                    audio_enabled: this.audioEnabled.checked
                };
                // å»é‡ï¼šç›¸åŒé…ç½®ä¸é‡å¤ä¸‹å‘ï¼Œé¿å…æ‰“æ–­å½“å‰TTS
                const key = JSON.stringify(payload);
                if (this._lastSessionUpdateKey === key) {
                    return;
                }
                this._lastSessionUpdateKey = key;
                this.ws.send(key);
                const t = new Date().toLocaleTimeString();
                console.log(`[${t}] å·²å‘é€ä¼šè¯æ›´æ–°:`, payload);
            }

            stopTranslation() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                
                this.stopRecording();
                this.stopVideoCapture();
                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.updateConnectionStatus('disconnected', 'å·²æ–­å¼€è¿æ¥');
            }

            startRecording() {
                // ä¼˜å…ˆä½¿ç”¨åŸºäºWebAudioçš„PCM16é‡‡é›†ï¼Œä¿è¯ä¸æœåŠ¡ç«¯/æ¨¡å‹çš„pcm16åè®®ä¸€è‡´
                try {
                    this.startPcmCapture();
                    return;
                } catch (e) {
                    console.error(`[${new Date().toLocaleTimeString()}] å¯åŠ¨PCMé‡‡é›†å¤±è´¥ï¼Œå›é€€åˆ°MediaRecorder:`, e);
                }

                // å›é€€æ–¹æ¡ˆï¼šä½¿ç”¨MediaRecorderï¼ˆå¯èƒ½æ˜¯æœ‰æŸå‹ç¼©ï¼Œæ¨¡å‹æœªå¿…æ¥å—ï¼‰
                if (this.mediaRecorder) return;
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] å›é€€ä½¿ç”¨MediaRecorderéŸ³é¢‘å½•åˆ¶...`);
                try {
                    const supportedTypes = [
                        'audio/webm',
                        'audio/webm;codecs=opus',
                        'audio/mp4',
                        'audio/ogg;codecs=opus'
                    ];
                    let selectedType = null;
                    for (const type of supportedTypes) {
                        if (window.MediaRecorder && MediaRecorder.isTypeSupported(type)) {
                            selectedType = type;
                            console.log(`[${timestamp}] ä½¿ç”¨éŸ³é¢‘æ ¼å¼: ${type}`);
                            break;
                        }
                    }
                    this.mediaRecorder = new MediaRecorder(this.stream, selectedType ? { mimeType: selectedType } : {});
                    this.mediaRecorder.ondataavailable = (event) => {
                        const t = new Date().toLocaleTimeString();
                        console.log(`[${t}] éŸ³é¢‘æ•°æ®å¯ç”¨: ${event.data.size} bytes, ç±»å‹: ${event.data.type}`);
                        if (event.data.size > 0 && this.ws && this.ws.readyState === WebSocket.OPEN) {
                            this.convertAndSendAudio(event.data);
                        }
                    };
                    this.mediaRecorder.onerror = (event) => {
                        console.error(`[${new Date().toLocaleTimeString()}] éŸ³é¢‘å½•åˆ¶é”™è¯¯:`, event);
                    };
                    this.mediaRecorder.start(100);
                    this.isRecording = true;
                    console.log(`[${timestamp}] å½•éŸ³å·²å¼€å§‹(MediaRecorder)`);
                } catch (error) {
                    console.error(`[${timestamp}] MediaRecorderåˆå§‹åŒ–å¤±è´¥:`, error);
                }
            }

            // ========= åŸºäºWebAudioçš„PCM16é‡‡é›† =========
            startPcmCapture() {
                if (!this.audioStream) throw new Error('æœªè·å–åˆ°åª’ä½“æµ');
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const timestamp = new Date().toLocaleTimeString();
                const inputSampleRate = this.audioContext.sampleRate;
                this.pcmTargetRate = 16000;
                console.log(`[${timestamp}] å¯åŠ¨PCMé‡‡é›†ï¼Œè¾“å…¥é‡‡æ ·ç‡: ${inputSampleRate}, ç›®æ ‡: ${this.pcmTargetRate}`);

                this.pcmSource = this.audioContext.createMediaStreamSource(this.audioStream);
                // ä½¿ç”¨è„šæœ¬å¤„ç†èŠ‚ç‚¹ï¼ˆå…¼å®¹æ€§å¥½ï¼‰ï¼›ç¼“å†²åŒºå¤§å°4096
                this.pcmProcessor = this.audioContext.createScriptProcessor(4096, 1, 1);
                this.pcmBuffer = new Float32Array(0);
                this.pcmInt16Acc = new Int16Array(0);
                this.pcmRemainder = new Float32Array(0);

                this.pcmProcessor.onaudioprocess = (e) => {
                    try {
                        const input = e.inputBuffer.getChannelData(0);
                        // ç´¯ç§¯å¹¶ä¸‹é‡‡æ ·åˆ°16k
                        const downsampled = this.downsampleTo16k(input, inputSampleRate, this.pcmTargetRate, this.pcmRemainder);
                        this.pcmRemainder = downsampled.remainder;
                        const float16k = downsampled.samples;
                        if (float16k.length === 0) return;

                        const int16 = this.floatTo16BitPCM(float16k);

                        // æŒ‰1600æ ·æœ¬(100ms@16k)åˆ‡ç‰‡å‘é€ï¼Œé™ä½æœåŠ¡å™¨å‹åŠ›
                        this.sendInt16InChunks(int16, 1600);
                    } catch (err) {
                        console.error(`[${new Date().toLocaleTimeString()}] PCMå¤„ç†é”™è¯¯:`, err);
                    }
                };

                this.pcmSource.connect(this.pcmProcessor);
                this.pcmProcessor.connect(this.audioContext.destination);
                this.isRecording = true;
            }

            stopPcmCapture() {
                if (this.pcmProcessor) {
                    try { this.pcmProcessor.disconnect(); } catch {}
                    this.pcmProcessor = null;
                }
                if (this.pcmSource) {
                    try { this.pcmSource.disconnect(); } catch {}
                    this.pcmSource = null;
                }
            }

            downsampleTo16k(inputFloat32, inputRate, targetRate, remainder) {
                if (inputRate === targetRate) {
                    // ç›´æ¥æ‹¼æ¥ä½™é‡
                    if (remainder && remainder.length) {
                        const merged = new Float32Array(remainder.length + inputFloat32.length);
                        merged.set(remainder, 0);
                        merged.set(inputFloat32, remainder.length);
                        return { samples: merged, remainder: new Float32Array(0) };
                    }
                    return { samples: inputFloat32, remainder: new Float32Array(0) };
                }
                const ratio = inputRate / targetRate;
                const total = (remainder ? remainder.length : 0) + inputFloat32.length;
                const buffer = new Float32Array(total);
                if (remainder && remainder.length) buffer.set(remainder, 0);
                buffer.set(inputFloat32, remainder ? remainder.length : 0);

                const newLength = Math.floor(buffer.length / ratio);
                const output = new Float32Array(newLength);
                let offsetResult = 0;
                let offsetBuffer = 0;
                while (offsetResult < output.length) {
                    const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
                    let accum = 0, count = 0;
                    for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
                        accum += buffer[i];
                        count++;
                    }
                    output[offsetResult] = accum / (count || 1);
                    offsetResult++;
                    offsetBuffer = nextOffsetBuffer;
                }
                // ä½™é‡ä¿ç•™
                const remainderStart = Math.floor(output.length * ratio);
                const rem = remainderStart < buffer.length ? buffer.slice(remainderStart) : new Float32Array(0);
                return { samples: output, remainder: rem };
            }

            floatTo16BitPCM(float32Array) {
                const int16 = new Int16Array(float32Array.length);
                for (let i = 0; i < float32Array.length; i++) {
                    let s = Math.max(-1, Math.min(1, float32Array[i]));
                    int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }
                return int16;
            }

            sendInt16InChunks(int16Array, samplesPerChunk) {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
                const totalSamples = int16Array.length;
                let offset = 0;
                while (offset < totalSamples) {
                    const end = Math.min(offset + samplesPerChunk, totalSamples);
                    const chunk = int16Array.subarray(offset, end);
                    const bytes = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
                    const message = new Uint8Array(bytes.length + 1);
                    message[0] = 0; // éŸ³é¢‘æ ‡è¯†
                    message.set(bytes, 1);
                    const t = new Date().toLocaleTimeString();
                    console.log(`[${t}] å‘é€PCM16éŸ³é¢‘å¸§: ${chunk.length} samples, ${bytes.length} bytes`);
                    this.ws.send(message);
                    offset = end;
                }
            }

            async convertAndSendAudio(audioBlob) {
                try {
                    const timestamp = new Date().toLocaleTimeString();
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    
                    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥è½¬æ¢ä¸º16kHz PCM
                    // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬ç›´æ¥å‘é€åŸå§‹éŸ³é¢‘æ•°æ®
                    const audioData = new Uint8Array(arrayBuffer);
                    
                    // æ·»åŠ æµç±»å‹æ ‡è¯† (0 = éŸ³é¢‘)
                    const message = new Uint8Array(audioData.length + 1);
                    message[0] = 0; // éŸ³é¢‘æµæ ‡è¯†
                    message.set(audioData, 1);
                    
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        console.log(`[${timestamp}] å®¢æˆ·ç«¯å‘é€éŸ³é¢‘æ•°æ®: ${audioData.length} bytes`);
                        this.ws.send(message);
                    } else {
                        console.warn(`[${timestamp}] WebSocketæœªè¿æ¥ï¼Œè·³è¿‡éŸ³é¢‘å‘é€`);
                    }
                } catch (error) {
                    console.error('è½¬æ¢éŸ³é¢‘æ•°æ®å¤±è´¥:', error);
                }
            }

            startVideoCapture() {
                if (this.videoIntervalId) return;

                // æ¯ç§’2å¸§å‘é€ç»™æœåŠ¡å™¨ï¼Œä½†å‰ç«¯æ˜¾ç¤ºä¿æŒæµç•…
                this.videoIntervalId = setInterval(async () => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        await this.captureAndSendFrame();
                    }
                }, 500); // 500ms = 2fpså‘é€åˆ°æœåŠ¡å™¨
                
                console.log('è§†é¢‘æ•è·å·²å¼€å§‹ (æ˜¾ç¤ºæµç•…, å‘é€2fps)');
            }

            toggleCamera() {
                // åŠ¨æ€æ‹‰å–/åœæ­¢è§†é¢‘æµ
                if (this.cameraEnabled.checked) {
                    // æ‹‰å–è§†é¢‘æµå¹¶å±•ç¤º
                    (async () => {
                        try {
                            this.videoStream = await navigator.mediaDevices.getUserMedia({
                                video: {
                                    width: { ideal: 640 },
                                    height: { ideal: 480 },
                                    frameRate: { ideal: 30 }
                                }
                            });
                            this.videoElement.srcObject = this.videoStream;
                            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                                this.startVideoCapture();
                            }
                        } catch (e) {
                            console.error('è·å–è§†é¢‘æµå¤±è´¥:', e);
                            this.cameraEnabled.checked = false;
                        }
                    })();
                } else {
                    this.stopVideoCapture();
                    if (this.videoStream) {
                        for (const track of this.videoStream.getTracks()) track.stop();
                        this.videoStream = null;
                        this.videoElement.srcObject = null;
                    }
                }
            }

            async captureAndSendFrame() {
                try {
                    const timestamp = new Date().toLocaleTimeString();
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = this.videoElement.videoWidth || 640;
                    canvas.height = this.videoElement.videoHeight || 480;
                    
                    ctx.drawImage(this.videoElement, 0, 0, canvas.width, canvas.height);
                    
                    // è½¬æ¢ä¸ºJPEGæ ¼å¼
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/jpeg', 0.8);
                    });
                    
                    if (blob) {
                        const imageData = await blob.arrayBuffer();
                        const imageArray = new Uint8Array(imageData);
                        
                        // æ·»åŠ æµç±»å‹æ ‡è¯† (1 = è§†é¢‘)
                        const message = new Uint8Array(imageArray.length + 1);
                        message[0] = 1; // è§†é¢‘æµæ ‡è¯†
                        message.set(imageArray, 1);
                        
                        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                            console.log(`[${timestamp}] å®¢æˆ·ç«¯å‘é€è§†é¢‘å¸§: ${imageArray.length} bytes`);
                            this.ws.send(message);
                        } else {
                            console.warn(`[${timestamp}] WebSocketæœªè¿æ¥ï¼Œè·³è¿‡è§†é¢‘å‘é€`);
                        }
                    }
                } catch (error) {
                    console.error('æ•è·è§†é¢‘å¸§å¤±è´¥:', error);
                }
            }

            stopRecording() {
                // åœæ­¢PCMé‡‡é›†
                this.stopPcmCapture();
                // åœæ­¢MediaRecorderï¼ˆè‹¥æ›¾å›é€€ä½¿ç”¨ï¼‰
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();
                    this.mediaRecorder = null;
                }
                this.isRecording = false;
                console.log('å½•éŸ³å·²åœæ­¢');
            }

            stopVideoCapture() {
                if (this.videoIntervalId) {
                    clearInterval(this.videoIntervalId);
                    this.videoIntervalId = null;
                }
                console.log('è§†é¢‘æ•è·å·²åœæ­¢');
            }

            appendTranslation(text) {
                const now = new Date().toLocaleTimeString();
                const translationHtml = `<div style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <small style="color: #666; font-size: 0.9rem;">${now}</small><br>
                    <strong style="color: #2c3e50;">${text}</strong>
                </div>`;
                
                this.translationContent.innerHTML = translationHtml + this.translationContent.innerHTML;
                
                // ä¿æŒæœ€è¿‘10æ¡è®°å½•
                const children = this.translationContent.children;
                if (children.length > 10) {
                    this.translationContent.removeChild(children[children.length - 1]);
                }
            }

            async playAudio(audioBlob) {
                try {
                    const timestamp = new Date().toLocaleTimeString();
                    console.log(`[${timestamp}] å¼€å§‹æ’­æ”¾éŸ³é¢‘ï¼ŒBlobå¤§å°: ${audioBlob.size} bytes, ç±»å‹: ${audioBlob.type}`);
                    
                    // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆ›å»º
                    if (!this.playbackAudioContext) {
                        this.playbackAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log(`[${timestamp}] åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡ï¼Œé‡‡æ ·ç‡: ${this.playbackAudioContext.sampleRate}`);
                    }
                    
                    // æ£€æŸ¥éŸ³é¢‘ä¸Šä¸‹æ–‡çŠ¶æ€
                    if (this.playbackAudioContext.state === 'suspended') {
                        console.log(`[${timestamp}] éŸ³é¢‘ä¸Šä¸‹æ–‡è¢«æŒ‚èµ·ï¼Œå°è¯•æ¢å¤...`);
                        await this.playbackAudioContext.resume();
                        console.log(`[${timestamp}] éŸ³é¢‘ä¸Šä¸‹æ–‡çŠ¶æ€: ${this.playbackAudioContext.state}`);
                    }
                    
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    console.log(`[${timestamp}] è½¬æ¢ä¸ºArrayBuffer: ${arrayBuffer.byteLength} bytes`);
                    
                    // å¤„ç†PCM16æ ¼å¼çš„éŸ³é¢‘æ•°æ®ï¼ˆä»æœåŠ¡å™¨æ¥æ”¶çš„åŸå§‹éŸ³é¢‘æ•°æ®ï¼‰
                    const int16Array = new Int16Array(arrayBuffer);
                    console.log(`[${timestamp}] Int16Arrayé•¿åº¦: ${int16Array.length}, å‰å‡ ä¸ªæ ·æœ¬: [${int16Array.slice(0, 5).join(', ')}]`);
                    
                    // æ£€æŸ¥éŸ³é¢‘æ•°æ®æ˜¯å¦æœ‰æ•ˆ
                    if (int16Array.length === 0) {
                        console.warn(`[${timestamp}] éŸ³é¢‘æ•°æ®ä¸ºç©º`);
                        return;
                    }
                    
                    const float32Array = new Float32Array(int16Array.length);
                    
                    // å°†Int16è½¬æ¢ä¸ºFloat32ï¼ˆ-1.0åˆ°1.0èŒƒå›´ï¼‰
                    for (let i = 0; i < int16Array.length; i++) {
                        float32Array[i] = int16Array[i] / 32768;
                    }
                    console.log(`[${timestamp}] è½¬æ¢ä¸ºFloat32Arrayï¼Œå‰å‡ ä¸ªæ ·æœ¬: [${float32Array.slice(0, 5).join(', ')}]`);
                    
                    // åˆ›å»ºéŸ³é¢‘ç¼“å†²åŒºï¼ˆ24kHzå•å£°é“ï¼‰
                    const audioBuffer = this.playbackAudioContext.createBuffer(1, float32Array.length, 24000);
                    audioBuffer.copyToChannel(float32Array, 0);
                    console.log(`[${timestamp}] åˆ›å»ºéŸ³é¢‘ç¼“å†²åŒº: 1å£°é“, ${float32Array.length}æ ·æœ¬, 24kHz`);
                    
                    // åˆ›å»ºéŸ³é¢‘æºå¹¶æ’­æ”¾
                    const source = this.playbackAudioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(this.playbackAudioContext.destination);
                    
                    const duration = (int16Array.length / 24000).toFixed(2);
                    console.log(`[${timestamp}] å‡†å¤‡æ’­æ”¾éŸ³é¢‘: ${int16Array.length} æ ·æœ¬, æ—¶é•¿çº¦ ${duration}ç§’`);
                    
                    source.onended = () => {
                        console.log(`[${new Date().toLocaleTimeString()}] éŸ³é¢‘æ’­æ”¾å®Œæˆ`);
                    };
                    
                    source.onerror = (error) => {
                        console.error(`[${new Date().toLocaleTimeString()}] éŸ³é¢‘æ’­æ”¾å‡ºé”™:`, error);
                    };
                    
                    source.start();
                    console.log(`[${timestamp}] éŸ³é¢‘å¼€å§‹æ’­æ”¾`);
                    
                } catch (error) {
                    console.error(`[${new Date().toLocaleTimeString()}] æ’­æ”¾éŸ³é¢‘å¤±è´¥:`, error);
                    console.error('é”™è¯¯å †æ ˆ:', error.stack);
                }
            }

            async enqueueAudioBlob(audioBlob) {
                try {
                    if (!this.playbackAudioContext) {
                        this.playbackAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const int16Array = new Int16Array(arrayBuffer);
                    if (int16Array.length === 0) return;
                    const float32Array = new Float32Array(int16Array.length);
                    for (let i = 0; i < int16Array.length; i++) {
                        float32Array[i] = int16Array[i] / 32768;
                    }
                    this.playbackQueue.push(float32Array);
                    const t = new Date().toLocaleTimeString();
                    console.log(`[${t}] å…¥é˜ŸéŸ³é¢‘ç‰‡æ®µ: ${float32Array.length} æ ·æœ¬ï¼Œå½“å‰é˜Ÿåˆ—: ${this.playbackQueue.length}`);
                    this.playNextAudioFromQueue();
                } catch (err) {
                    console.error('enqueueAudioBlobå¤±è´¥:', err);
                }
            }

            playNextAudioFromQueue() {
                if (this.isAudioPlaying) return;
                if (!this.playbackQueue.length) return;

                const float32Array = this.playbackQueue.shift();
                this.isAudioPlaying = true;

                if (!this.playbackAudioContext) {
                    this.playbackAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                const audioBuffer = this.playbackAudioContext.createBuffer(1, float32Array.length, 24000);
                audioBuffer.copyToChannel(float32Array, 0);

                const source = this.playbackAudioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(this.playbackAudioContext.destination);

                const t = new Date().toLocaleTimeString();
                console.log(`[${t}] æ’­æ”¾é˜Ÿåˆ—éŸ³é¢‘: ${float32Array.length} æ ·æœ¬ï¼Œå‰©ä½™é˜Ÿåˆ—: ${this.playbackQueue.length}`);

                source.onended = () => {
                    this.isAudioPlaying = false;
                    this.playNextAudioFromQueue();
                };
                source.start();
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            new LiveTranslateApp();
        });
    </script>
</body>
</html>
